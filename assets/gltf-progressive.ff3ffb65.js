var Xe=Object.defineProperty;var qe=(o,e,t)=>e in o?Xe(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var d=(o,e,t)=>(qe(o,typeof e!="symbol"?e+"":e,t),t),Ae=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var m=(o,e,t)=>(Ae(o,e,"read from private field"),t?t.call(o):e.get(o)),H=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},N=(o,e,t,s)=>(Ae(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t);import{B as he,M as Z,T as se,a as Ye,b as Pe,C as He,c as Je,S as Qe,d as Ce,V as W}from"./three@0.169.5.js";import{D as Ze,K as je,G as Te,M as et}from"./three-examples.d909655c.js";const Re="2.1.3";globalThis.GLTF_PROGRESSIVE_VERSION=Re;console.debug(`[gltf-progressive] version ${Re}`);let z="https://www.gstatic.com/draco/versioned/decoders/1.5.7/",j="https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";const tt=z,st=j,Ge=new URL(z+"draco_decoder.js");Ge.searchParams.append("range","true");fetch(Ge,{method:"GET",headers:{Range:"bytes=0-1"}}).catch(o=>{console.debug(`Failed to fetch remote Draco decoder from ${z} (offline: ${typeof navigator<"u"?navigator.onLine:"unknown"})`),z===tt&&rt("./include/draco/"),j===st&&nt("./include/ktx2/")}).finally(()=>{$e()});function rt(o){z=o,B&&B[ve]!=z?(console.debug("Updating Draco decoder path to "+o),B[ve]=z,B.setDecoderPath(z),B.preload()):console.debug("Setting Draco decoder path to "+o)}function nt(o){j=o,$&&$.transcoderPath!=j?(console.debug("Updating KTX2 transcoder path to "+o),$.setTranscoderPath(j),$.init()):console.debug("Setting KTX2 transcoder path to "+o)}const ve=Symbol("dracoDecoderPath");let B,ge,$;function $e(){B||(B=new Ze,B[ve]=z,B.setDecoderPath(z),B.setDecoderConfig({type:"js"}),B.preload()),$||($=new je,$.setTranscoderPath(j),$.init()),ge||(ge=et)}function Ue(o){return $e(),o?$.detectSupport(o):o!==null&&console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"),{dracoLoader:B,ktx2Loader:$,meshoptDecoder:ge}}function Fe(o){o.dracoLoader||o.setDRACOLoader(B),o.ktx2Loader||o.setKTX2Loader($),o.meshoptDecoder||o.setMeshoptDecoder(ge)}const _e=new WeakMap;function Ne(o,e){let t=_e.get(o);t?t=Object.assign(t,e):t=e,_e.set(o,t)}const De=Te.prototype.load;function it(...o){const e=_e.get(this);let t=o[0];const s=new URL(t,window.location.href);if(s.hostname.endsWith("needle.tools")){const n=(e==null?void 0:e.progressive)!==void 0?e.progressive:!0,r=e!=null&&e.usecase?e.usecase:"default";n?this.requestHeader.Accept=`*/*;progressive=allowed;usecase=${r}`:this.requestHeader.Accept=`*/*;usecase=${r}`,t=s.toString()}return o[0]=t,De==null?void 0:De.call(this,...o)}Te.prototype.load=it;ae("debugprogressive");function ae(o){if(typeof window>"u")return!1;const t=new URL(window.location.href).searchParams.get(o);return t==null||t==="0"||t==="false"?!1:t===""?!0:t}function ot(o,e){if(e===void 0||e.startsWith("./")||e.startsWith("http")||o===void 0)return e;const t=o.lastIndexOf("/");if(t>=0){const s=o.substring(0,t+1);for(;s.endsWith("/")&&e.startsWith("/");)e=e.substring(1);return s+e}return e}let re;function at(){return re!==void 0||(re=/iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent),ae("debugprogressive")&&console.log("[glTF Progressive]: isMobileDevice",re)),re}const lt=typeof window>"u"&&typeof document>"u",be=Symbol("needle:raycast-mesh");function le(o){return(o==null?void 0:o[be])instanceof he?o[be]:null}function ct(o,e){if((o.type==="Mesh"||o.type==="SkinnedMesh")&&!le(o)){const s=ut(e);s.userData={isRaycastMesh:!0},o[be]=s}}function ft(o=!0){if(o){if(ne)return;const e=ne=Z.prototype.raycast;Z.prototype.raycast=function(t,s){const i=this,n=le(i);let r;n&&i.isMesh&&(r=i.geometry,i.geometry=n),e.call(this,t,s),r&&(i.geometry=r)}}else{if(!ne)return;Z.prototype.raycast=ne,ne=null}}let ne=null;function ut(o){const e=new he;for(const t in o.attributes)e.setAttribute(t,o.getAttribute(t));return e.setIndex(o.getIndex()),e}const Q=new Array,K="NEEDLE_progressive",L=ae("debugprogressive"),Me=Symbol("needle-progressive-texture"),oe=new Map,Se=new Set;if(L){let s=function(){o+=1,console.log("Toggle LOD level",o,oe),oe.forEach((i,n)=>{for(const r of i.keys){const a=n[r];if(a!=null)if(a.isBufferGeometry===!0){const l=A.getMeshLODInformation(a),f=l?Math.min(o,l.lods.length):0;n["DEBUG:LOD"]=f,l&&(e=Math.max(e,l.lods.length-1))}else n.isMaterial===!0&&(n["DEBUG:LOD"]=o)}}),o>=e&&(o=-1)},o=-1,e=2,t=!1;window.addEventListener("keyup",i=>{i.key==="p"&&s(),i.key==="w"&&(t=!t,Se&&Se.forEach(n=>{n.name!="BackgroundCubeMaterial"&&n.glyphMap==null&&"wireframe"in n&&(n.wireframe=t)}))})}function Ee(o,e,t){var i;if(!L)return;oe.has(o)||oe.set(o,{keys:[],sourceId:t});const s=oe.get(o);((i=s==null?void 0:s.keys)==null?void 0:i.includes(e))==!1&&s.keys.push(e)}const v=class{constructor(e,t){d(this,"parser");d(this,"url");d(this,"_isLoadingMesh");d(this,"loadMesh",e=>{var s,i;if(this._isLoadingMesh)return null;const t=(i=(s=this.parser.json.meshes[e])==null?void 0:s.extensions)==null?void 0:i[K];return t?(this._isLoadingMesh=!0,this.parser.getDependency("mesh",e).then(n=>{var r;return this._isLoadingMesh=!1,n&&v.registerMesh(this.url,t.guid,n,(r=t.lods)==null?void 0:r.length,void 0,t),n})):null});L&&console.log("Progressive extension registered for",t),this.parser=e,this.url=t}get name(){return K}static getMeshLODInformation(e){const t=this.getAssignedLODInformation(e);return t!=null&&t.key?this.lodInfos.get(t.key):null}static getMaterialMinMaxLODsCount(e,t){const s=this,i="LODS:minmax",n=e[i];if(n!=null)return n;if(t||(t={min_count:1/0,max_count:0,lods:[]}),Array.isArray(e)){for(const a of e)this.getMaterialMinMaxLODsCount(a,t);return e[i]=t,t}if(L==="verbose"&&console.log("getMaterialMinMaxLODsCount",e),e.type==="ShaderMaterial"||e.type==="RawShaderMaterial"){const a=e;for(const l of Object.keys(a.uniforms)){const f=a.uniforms[l].value;(f==null?void 0:f.isTexture)===!0&&r(f,t)}}else if(e.isMaterial)for(const a of Object.keys(e)){const l=e[a];(l==null?void 0:l.isTexture)===!0&&r(l,t)}return e[i]=t,t;function r(a,l){const f=s.getAssignedLODInformation(a);if(f){const c=s.lodInfos.get(f.key);if(c&&c.lods){l.min_count=Math.min(l.min_count,c.lods.length),l.max_count=Math.max(l.max_count,c.lods.length);for(let g=0;g<c.lods.length;g++){const p=c.lods[g];p.width&&(l.lods[g]=l.lods[g]||{min_height:1/0,max_height:0},l.lods[g].min_height=Math.min(l.lods[g].min_height,p.height),l.lods[g].max_height=Math.max(l.lods[g].max_height,p.height))}}}}}static hasLODLevelAvailable(e,t){var n;if(Array.isArray(e)){for(const r of e)if(this.hasLODLevelAvailable(r,t))return!0;return!1}if(e.isMaterial===!0){for(const r of Object.keys(e)){const a=e[r];if(a&&a.isTexture&&this.hasLODLevelAvailable(a,t))return!0}return!1}else if(e.isGroup===!0){for(const r of e.children)if(r.isMesh===!0&&this.hasLODLevelAvailable(r,t))return!0}let s,i;if(e.isMesh?s=e.geometry:(e.isBufferGeometry||e.isTexture)&&(s=e),s&&(n=s==null?void 0:s.userData)!=null&&n.LODS){const r=s.userData.LODS;if(i=this.lodInfos.get(r.key),t===void 0)return i!=null;if(i)return Array.isArray(i.lods)?t<i.lods.length:t===0}return!1}static assignMeshLOD(e,t){var s;if(!e)return Promise.resolve(null);if(e instanceof Z||e.isMesh===!0){const i=e.geometry,n=this.getAssignedLODInformation(i);if(!n)return Promise.resolve(null);for(const r of Q)(s=r.onBeforeGetLODMesh)==null||s.call(r,e,t);return e["LOD:requested level"]=t,v.getOrLoadLOD(i,t).then(r=>{if(Array.isArray(r)){const a=n.index||0;r=r[a]}return e["LOD:requested level"]===t&&(delete e["LOD:requested level"],r&&i!=r&&((r==null?void 0:r.isBufferGeometry)?(e.geometry=r,L&&Ee(e,"geometry",n.url)):L&&console.error("Invalid LOD geometry",r))),r}).catch(r=>(console.error("Error loading mesh LOD",e,r),null))}else L&&console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh",e);return Promise.resolve(null)}static assignTextureLOD(e,t=0){if(!e)return Promise.resolve(null);if(e.isMesh===!0){const s=e;if(Array.isArray(s.material)){const i=new Array;for(const n of s.material){const r=this.assignTextureLOD(n,t);i.push(r)}return Promise.all(i).then(n=>{const r=new Array;for(const a of n)Array.isArray(a)&&r.push(...a);return r})}else return this.assignTextureLOD(s.material,t)}if(e.isMaterial===!0){const s=e,i=[],n=new Array;if(L&&Se.add(s),s.uniforms&&(s.isRawShaderMaterial||s.isShaderMaterial===!0)){const r=s;for(const a of Object.keys(r.uniforms)){const l=r.uniforms[a].value;if((l==null?void 0:l.isTexture)===!0){const f=this.assignTextureLODForSlot(l,t,s,a).then(c=>(c&&r.uniforms[a].value!=c&&(r.uniforms[a].value=c,r.uniformsNeedUpdate=!0),c));i.push(f),n.push(a)}}}else for(const r of Object.keys(s)){const a=s[r];if((a==null?void 0:a.isTexture)===!0){const l=this.assignTextureLODForSlot(a,t,s,r);i.push(l),n.push(r)}}return Promise.all(i).then(r=>{const a=new Array;for(let l=0;l<r.length;l++){const f=r[l],c=n[l];f&&f.isTexture===!0?a.push({material:s,slot:c,texture:f,level:t}):a.push({material:s,slot:c,texture:null,level:t})}return a})}if(e instanceof se||e.isTexture===!0){const s=e;return this.assignTextureLODForSlot(s,t,null,null)}return Promise.resolve(null)}static assignTextureLODForSlot(e,t,s,i){return(e==null?void 0:e.isTexture)!==!0?Promise.resolve(null):i==="glyphMap"?Promise.resolve(e):v.getOrLoadLOD(e,t).then(n=>{if(Array.isArray(n))return null;if((n==null?void 0:n.isTexture)===!0){if(n!=e){if(s&&i){const r=s[i];if(r&&!L){const a=this.getAssignedLODInformation(r);if(a&&(a==null?void 0:a.level)<t)return L==="verbose"&&console.warn("Assigned texture level is already higher: ",a.level,t,s,r,n),null}s[i]=n}if(L&&i&&s){const r=this.getAssignedLODInformation(e);r?Ee(s,i,r.url):console.warn("No LOD info for texture",e)}}return n}else L=="verbose"&&console.warn("No LOD found for",e,t);return null}).catch(n=>(console.error("Error loading LOD",e,n),null))}afterRoot(e){var t,s;return L&&console.log("AFTER",this.url,e),(t=this.parser.json.textures)==null||t.forEach((i,n)=>{var r;if(i!=null&&i.extensions){const a=i==null?void 0:i.extensions[K];if(a){if(!a.lods){L&&console.warn("Texture has no LODs",a);return}let l=!1;for(const f of this.parser.associations.keys())if(f.isTexture===!0){const c=this.parser.associations.get(f);(c==null?void 0:c.textures)===n&&(l=!0,v.registerTexture(this.url,f,(r=a.lods)==null?void 0:r.length,n,a))}l||this.parser.getDependency("texture",n).then(f=>{var c;f&&v.registerTexture(this.url,f,(c=a.lods)==null?void 0:c.length,n,a)})}}}),(s=this.parser.json.meshes)==null||s.forEach((i,n)=>{if(i!=null&&i.extensions){const r=i==null?void 0:i.extensions[K];if(r&&r.lods){for(const a of this.parser.associations.keys())if(a.isMesh){const l=this.parser.associations.get(a);(l==null?void 0:l.meshes)===n&&v.registerMesh(this.url,r.guid,a,r.lods.length,l.primitives,r)}}}}),null}static async getOrLoadLOD(e,t){var a,l,f,c;const s=L=="verbose",i=e.userData.LODS;if(!i)return null;const n=i==null?void 0:i.key;let r;if(e.isTexture===!0){const g=e;g.source&&g.source[Me]&&(r=g.source[Me])}if(r||(r=v.lodInfos.get(n)),r){if(t>0){let M=!1;const O=Array.isArray(r.lods);if(O&&t>=r.lods.length?M=!0:O||(M=!0),M)return this.lowresCache.get(n)}const g=Array.isArray(r.lods)?(a=r.lods[t])==null?void 0:a.path:r.lods;if(!g)return L&&!r["missing:uri"]&&(r["missing:uri"]=!0,console.warn("Missing uri for progressive asset for LOD "+t,r)),null;const p=ot(i.url,g);if(p.endsWith(".glb")||p.endsWith(".gltf")){if(!r.guid)return console.warn("missing pointer for glb/gltf texture",r),null;const M=p+"_"+r.guid,O=this.previouslyLoaded.get(M);if(O!==void 0){s&&console.log(`LOD ${t} was already loading/loaded: ${M}`);let h=await O.catch(F=>(console.error(`Error loading LOD ${t} from ${p}
`,F),null)),k=!1;if(h==null||(h instanceof se&&e instanceof se?(l=h.image)!=null&&l.data||(f=h.source)!=null&&f.data?h=this.copySettings(e,h):(k=!0,this.previouslyLoaded.delete(M)):h instanceof he&&e instanceof he&&((c=h.attributes.position)!=null&&c.array||(k=!0,this.previouslyLoaded.delete(M)))),!k)return h}const x=r,U=new Promise(async(h,k)=>{const F=new Te;Fe(F),L&&(await new Promise(S=>setTimeout(S,1e3)),s&&console.warn("Start loading (delayed) "+p,x.guid));let I=p;if(x&&Array.isArray(x.lods)){const S=x.lods[t];S.hash&&(I+="?v="+S.hash)}const P=await F.loadAsync(I).catch(S=>(console.error(`Error loading LOD ${t} from ${p}
`,S),null));if(!P)return null;const V=P.parser;s&&console.log("Loading finished "+p,x.guid);let b=0;if(P.parser.json.textures){let S=!1;for(const u of P.parser.json.textures){if(u!=null&&u.extensions){const y=u==null?void 0:u.extensions[K];if(y!=null&&y.guid&&y.guid===x.guid){S=!0;break}}b++}if(S){let u=await V.getDependency("texture",b);return u&&v.assignLODInformation(i.url,u,n,t,void 0,void 0),s&&console.log('change "'+e.name+'" → "'+u.name+'"',p,b,u,M),e instanceof se&&(u=this.copySettings(e,u)),u&&(u.guid=x.guid),h(u)}else L&&console.warn("Could not find texture with guid",x.guid,P.parser.json)}if(b=0,P.parser.json.meshes){let S=!1;for(const u of P.parser.json.meshes){if(u!=null&&u.extensions){const y=u==null?void 0:u.extensions[K];if(y!=null&&y.guid&&y.guid===x.guid){S=!0;break}}b++}if(S){const u=await V.getDependency("mesh",b),y=x;if(s&&console.log(`Loaded Mesh "${u.name}"`,p,b,u,M),u.isMesh===!0){const _=u.geometry;return v.assignLODInformation(i.url,_,n,t,void 0,y.density),h(_)}else{const _=new Array;for(let T=0;T<u.children.length;T++){const C=u.children[T];if(C.isMesh===!0){const Y=C.geometry;v.assignLODInformation(i.url,Y,n,t,T,y.density),_.push(Y)}}return h(_)}}else L&&console.warn("Could not find mesh with guid",x.guid,P.parser.json)}return h(null)});return this.previouslyLoaded.set(M,U),await U}else if(e instanceof se){s&&console.log("Load texture from uri: "+p);const O=await new Ye().loadAsync(p);return O?(O.guid=r.guid,O.flipY=!1,O.needsUpdate=!0,O.colorSpace=e.colorSpace,s&&console.log(r,O)):L&&console.warn("failed loading",p),O}}else L&&console.warn(`Can not load LOD ${t}: no LOD info found for "${n}" ${e.name}`,e.type);return null}static assignLODInformation(e,t,s,i,n,r){if(!t)return;t.userData||(t.userData={});const a=new dt(e,s,i,n,r);t.userData.LODS=a}static getAssignedLODInformation(e){var t;return((t=e==null?void 0:e.userData)==null?void 0:t.LODS)||null}static copySettings(e,t){return t?(L&&console.warn(`Copy texture settings
`,e.uuid,`
`,t.uuid),t=t.clone(),t.offset=e.offset,t.repeat=e.repeat,t.colorSpace=e.colorSpace,t.magFilter=e.magFilter,t.minFilter=e.minFilter,t.wrapS=e.wrapS,t.wrapT=e.wrapT,t.flipY=e.flipY,t.anisotropy=e.anisotropy,t.mipmaps||(t.generateMipmaps=e.generateMipmaps),t):e}};let A=v;d(A,"registerTexture",(e,t,s,i,n)=>{if(L&&console.log("> Progressive: register texture",i,t.name,t.uuid,t,n),!t){L&&console.error("gltf-progressive: Register texture without texture");return}t.source&&(t.source[Me]=n);const r=n.guid;v.assignLODInformation(e,t,r,s,i,void 0),v.lodInfos.set(r,n),v.lowresCache.set(r,t)}),d(A,"registerMesh",(e,t,s,i,n,r)=>{var f;L&&console.log("> Progressive: register mesh",n,s.name,r,s.uuid,s);const a=s.geometry;if(!a){L&&console.warn("gltf-progressive: Register mesh without geometry");return}a.userData||(a.userData={}),v.assignLODInformation(e,a,t,i,n,r.density),v.lodInfos.set(t,r);let l=v.lowresCache.get(t);l?l.push(s.geometry):l=[s.geometry],v.lowresCache.set(t,l),i>0&&!le(s)&&ct(s,a);for(const c of Q)(f=c.onRegisteredNewMesh)==null||f.call(c,s,r)}),d(A,"lodInfos",new Map),d(A,"previouslyLoaded",new Map),d(A,"lowresCache",new Map);class dt{constructor(e,t,s,i,n){d(this,"url");d(this,"key");d(this,"level");d(this,"index");d(this,"density");this.url=e,this.key=t,this.level=s,i!=null&&(this.index=i),n!=null&&(this.density=n)}}const R=ae("debugprogressive"),ht=ae("noprogressive"),we=Symbol("Needle:LODSManager"),Oe=Symbol("Needle:LODState"),J=Symbol("Needle:CurrentLOD"),G={mesh_lod:-1,texture_lod:-1};var w,E,X,ye,ee,te,me,q;let pe=(w=class{constructor(e,t){d(this,"context");d(this,"renderer");d(this,"projectionScreenMatrix",new Pe);d(this,"targetTriangleDensity",2e5);d(this,"updateInterval","auto");H(this,E,1);d(this,"pause",!1);d(this,"manual",!1);d(this,"_lodchangedlisteners",[]);H(this,X,void 0);H(this,ye,new He);H(this,ee,0);H(this,te,0);H(this,me,0);H(this,q,0);d(this,"_fpsBuffer",[60,60,60,60,60]);d(this,"_sphere",new Qe);d(this,"_tempBox",new Ce);d(this,"_tempBox2",new Ce);d(this,"tempMatrix",new Pe);d(this,"_tempWorldPosition",new W);d(this,"_tempBoxSize",new W);d(this,"_tempBox2Size",new W);this.renderer=e,this.context={...t}}static getObjectLODState(e){return e[Oe]}static addPlugin(e){Q.push(e)}static removePlugin(e){const t=Q.indexOf(e);t>=0&&Q.splice(t,1)}static get(e,t){if(e[we])return console.debug("[gltf-progressive] LODsManager already exists for this renderer"),e[we];const s=new w(e,{engine:"unknown",...t});return e[we]=s,s}get plugins(){return Q}addEventListener(e,t){e==="changed"&&this._lodchangedlisteners.push(t)}removeEventListener(e,t){if(e==="changed"){const s=this._lodchangedlisteners.indexOf(t);s>=0&&this._lodchangedlisteners.splice(s,1)}}enable(){if(m(this,X))return;console.debug("[gltf-progressive] Enabling LODsManager for renderer");let e=0;N(this,X,this.renderer.render);const t=this;Ue(this.renderer),this.renderer.render=function(s,i){const n=t.renderer.getRenderTarget();(n==null||"isXRRenderTarget"in n&&n.isXRRenderTarget)&&(e=0,N(t,ee,m(t,ee)+1),N(t,te,m(t,ye).getDelta()),N(t,me,m(t,me)+m(t,te)),t._fpsBuffer.shift(),t._fpsBuffer.push(1/m(t,te)),N(t,q,t._fpsBuffer.reduce((a,l)=>a+l)/t._fpsBuffer.length),R&&m(t,ee)%200===0&&console.log("FPS",Math.round(m(t,q)),"Interval:",m(t,E)));const r=e++;m(t,X).call(this,s,i),t.onAfterRender(s,i,r)}}disable(){m(this,X)&&(console.debug("[gltf-progressive] Disabling LODsManager for renderer"),this.renderer.render=m(this,X),N(this,X,void 0))}update(e,t){this.internalUpdate(e,t)}onAfterRender(e,t,s){if(this.pause)return;const n=this.renderer.renderLists.get(e,0).opaque;let r=!0;if(n.length===1){const a=n[0].material;(a.name==="EffectMaterial"||a.name==="CopyShader")&&(r=!1)}if((t.parent&&t.parent.type==="CubeCamera"||s>=1&&t.type==="OrthographicCamera")&&(r=!1),r){if(ht||(this.updateInterval==="auto"?m(this,q)<40&&m(this,E)<10?(N(this,E,m(this,E)+1),R&&console.warn("↓ Reducing LOD updates",m(this,E),m(this,q).toFixed(0))):m(this,q)>=60&&m(this,E)>1&&(N(this,E,m(this,E)-1),R&&console.warn("↑ Increasing LOD updates",m(this,E),m(this,q).toFixed(0))):N(this,E,this.updateInterval),m(this,E)>0&&m(this,ee)%m(this,E)!=0))return;this.internalUpdate(e,t)}}internalUpdate(e,t){var l,f;const s=this.renderer.renderLists.get(e,0),i=s.opaque;this.projectionScreenMatrix.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse);const n=this.targetTriangleDensity;for(const c of i){if(c.material&&(((l=c.geometry)==null?void 0:l.type)==="BoxGeometry"||((f=c.geometry)==null?void 0:f.type)==="BufferGeometry")&&(c.material.name==="SphericalGaussianBlur"||c.material.name=="BackgroundCubeMaterial"||c.material.name==="CubemapFromEquirect"||c.material.name==="EquirectangularToCubeUV")){R&&(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]||(c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"]=!0,console.warn("Ignoring skybox or BLIT object",c,c.material.name,c.material.type)));continue}switch(c.material.type){case"LineBasicMaterial":case"LineDashedMaterial":case"PointsMaterial":case"ShadowMaterial":case"MeshDistanceMaterial":case"MeshDepthMaterial":continue}if(R==="color"&&c.material&&!c.object.progressive_debug_color){c.object.progressive_debug_color=!0;const p=Math.random()*16777215,M=new Je({color:p});c.object.material=M}const g=c.object;(g instanceof Z||g.isMesh)&&this.updateLODs(e,t,g,n)}const r=s.transparent;for(const c of r){const g=c.object;(g instanceof Z||g.isMesh)&&this.updateLODs(e,t,g,n)}const a=s.transmissive;for(const c of a){const g=c.object;(g instanceof Z||g.isMesh)&&this.updateLODs(e,t,g,n)}}updateLODs(e,t,s,i){var a,l;s.userData||(s.userData={});let n=s[Oe];if(n||(n=new gt,s[Oe]=n),n.frames++<2)return;for(const f of Q)(a=f.onBeforeUpdateLOD)==null||a.call(f,this.renderer,e,t,s);this.calculateLodLevel(t,s,n,i,G),G.mesh_lod=Math.round(G.mesh_lod),G.texture_lod=Math.round(G.texture_lod),G.mesh_lod>=0&&this.loadProgressiveMeshes(s,G.mesh_lod);let r=G.texture_lod;s.material&&r>=0&&this.loadProgressiveTextures(s.material,r);for(const f of Q)(l=f.onAfterUpdatedLOD)==null||l.call(f,this.renderer,e,t,s,G);n.lastLodLevel_Mesh=G.mesh_lod,n.lastLodLevel_Texture=G.texture_lod}loadProgressiveTextures(e,t){if(!e)return;if(Array.isArray(e)){for(const n of e)this.loadProgressiveTextures(n,t);return}let s=!1;(e[J]===void 0||t<e[J])&&(s=!0);const i=e["DEBUG:LOD"];i!=null&&(s=e[J]!=i,t=i),s&&(e[J]=t,A.assignTextureLOD(e,t).then(n=>{this._lodchangedlisteners.forEach(r=>r({type:"texture",level:t,object:e}))}))}loadProgressiveMeshes(e,t){if(!e)return Promise.resolve(null);let s=e[J]!==t;const i=e["DEBUG:LOD"];if(i!=null&&(s=e[J]!=i,t=i),s){e[J]=t;const n=e.geometry;return A.assignMeshLOD(e,t).then(r=>(r&&e[J]==t&&n!=e.geometry&&this._lodchangedlisteners.forEach(a=>a({type:"mesh",level:t,object:e})),r))}return Promise.resolve(null)}static isInside(e,t){const s=e.min,i=e.max,n=(s.x+i.x)*.5,r=(s.y+i.y)*.5;return this._tempPtInside.set(n,r,s.z).applyMatrix4(t).z<0}calculateLodLevel(e,t,s,i,n){var U;if(!t){n.mesh_lod=-1,n.texture_lod=-1;return}if(!e){n.mesh_lod=-1,n.texture_lod=-1;return}let a=10+1,l=!1;if(R&&t["DEBUG:LOD"]!=null)return t["DEBUG:LOD"];const f=A.getMeshLODInformation(t.geometry),c=f==null?void 0:f.lods,g=c&&c.length>0,p=A.getMaterialMinMaxLODsCount(t.material),M=(p==null?void 0:p.min_count)!=1/0&&p.min_count>0&&p.max_count>0;if(!g&&!M){n.mesh_lod=0,n.texture_lod=0;return}g||(l=!0,a=0);const O=this.renderer.domElement.clientHeight||this.renderer.domElement.height;let x=t.geometry.boundingBox;if(t.type==="SkinnedMesh"){const D=t;if(!D.boundingBox)D.computeBoundingBox();else if(s.frames%30===0){const h=le(D),k=D.geometry;h&&(D.geometry=h),D.computeBoundingBox(),D.geometry=k}x=D.boundingBox}if(x){const D=e;if(t.geometry.attributes.color&&t.geometry.attributes.color.count<100&&t.geometry.boundingSphere){this._sphere.copy(t.geometry.boundingSphere),this._sphere.applyMatrix4(t.matrixWorld);const u=e.getWorldPosition(this._tempWorldPosition);if(this._sphere.containsPoint(u)){n.mesh_lod=0,n.texture_lod=0;return}}if(this._tempBox.copy(x),this._tempBox.applyMatrix4(t.matrixWorld),D.isPerspectiveCamera&&w.isInside(this._tempBox,this.projectionScreenMatrix)){n.mesh_lod=0,n.texture_lod=0;return}if(this._tempBox.applyMatrix4(this.projectionScreenMatrix),this.renderer.xr.enabled&&D.isPerspectiveCamera&&D.fov>70){const u=this._tempBox.min,y=this._tempBox.max;let _=u.x,T=u.y,C=y.x,Y=y.y;const ce=2,Le=1.5,fe=(u.x+y.x)*.5,ue=(u.y+y.y)*.5;_=(_-fe)*ce+fe,T=(T-ue)*ce+ue,C=(C-fe)*ce+fe,Y=(Y-ue)*ce+ue;const We=_<0&&C>0?0:Math.min(Math.abs(u.x),Math.abs(y.x)),Ke=T<0&&Y>0?0:Math.min(Math.abs(u.y),Math.abs(y.y)),xe=Math.max(We,Ke);s.lastCentrality=(Le-xe)*(Le-xe)*(Le-xe)}else s.lastCentrality=1;const h=this._tempBox.getSize(this._tempBoxSize);h.multiplyScalar(.5),screen.availHeight>0&&O>0&&h.multiplyScalar(O/screen.availHeight),e.isPerspectiveCamera?h.x*=e.aspect:e.isOrthographicCamera;const k=e.matrixWorldInverse,F=this._tempBox2;F.copy(x),F.applyMatrix4(t.matrixWorld),F.applyMatrix4(k);const I=F.getSize(this._tempBox2Size),P=Math.max(I.x,I.y);if(Math.max(h.x,h.y)!=0&&P!=0&&(h.z=I.z/Math.max(I.x,I.y)*Math.max(h.x,h.y)),s.lastScreenCoverage=Math.max(h.x,h.y,h.z),s.lastScreenspaceVolume.copy(h),s.lastScreenCoverage*=s.lastCentrality,R&&w.debugDrawLine){const u=this.tempMatrix.copy(this.projectionScreenMatrix);u.invert();const y=w.corner0,_=w.corner1,T=w.corner2,C=w.corner3;y.copy(this._tempBox.min),_.copy(this._tempBox.max),_.x=y.x,T.copy(this._tempBox.max),T.y=y.y,C.copy(this._tempBox.max);const Y=(y.z+C.z)*.5;y.z=_.z=T.z=C.z=Y,y.applyMatrix4(u),_.applyMatrix4(u),T.applyMatrix4(u),C.applyMatrix4(u),w.debugDrawLine(y,_,255),w.debugDrawLine(y,T,255),w.debugDrawLine(_,C,255),w.debugDrawLine(T,C,255)}let b=999;if(c&&s.lastScreenCoverage>0){for(let u=0;u<c.length;u++)if(c[u].density/s.lastScreenCoverage<i){b=u;break}}b<a&&(a=b,l=!0)}if(l?n.mesh_lod=a:n.mesh_lod=s.lastLodLevel_Mesh,R&&n.mesh_lod!=s.lastLodLevel_Mesh){const h=c==null?void 0:c[n.mesh_lod];h&&console.log(`Mesh LOD changed: ${s.lastLodLevel_Mesh} → ${n.mesh_lod} (${h.density.toFixed(0)}) - ${t.name}`)}if(M){const D="saveData"in globalThis.navigator&&globalThis.navigator.saveData===!0;if(s.lastLodLevel_Texture<0){if(n.texture_lod=p.max_count-1,R){const h=p.lods[p.max_count-1];R&&console.log(`First Texture LOD ${n.texture_lod} (${h.max_height}px) - ${t.name}`)}}else{const h=s.lastScreenspaceVolume.x+s.lastScreenspaceVolume.y+s.lastScreenspaceVolume.z;let k=s.lastScreenCoverage*4;((U=this.context)==null?void 0:U.engine)==="model-viewer"&&(k*=1.5);const I=O/window.devicePixelRatio*k;let P=!1;for(let V=p.lods.length-1;V>=0;V--){let b=p.lods[V];if(!(D&&b.max_height>=2048)&&!(at()&&b.max_height>4096)&&(b.max_height>I||!P&&V===0)){if(P=!0,n.texture_lod=V,n.texture_lod<s.lastLodLevel_Texture){const S=b.max_height;R&&console.log(`Texture LOD changed: ${s.lastLodLevel_Texture} → ${n.texture_lod} = ${S}px 
Screensize: ${I.toFixed(0)}px, Coverage: ${(100*s.lastScreenCoverage).toFixed(2)}%, Volume ${h.toFixed(1)} 
${t.name}`)}break}}}}else n.texture_lod=0}},E=new WeakMap,X=new WeakMap,ye=new WeakMap,ee=new WeakMap,te=new WeakMap,me=new WeakMap,q=new WeakMap,d(w,"debugDrawLine"),d(w,"corner0",new W),d(w,"corner1",new W),d(w,"corner2",new W),d(w,"corner3",new W),d(w,"_tempPtInside",new W),w);class gt{constructor(){d(this,"frames",0);d(this,"lastLodLevel_Mesh",-1);d(this,"lastLodLevel_Texture",-1);d(this,"lastScreenCoverage",0);d(this,"lastScreenspaceVolume",new W);d(this,"lastCentrality",0)}}const Be=Symbol("NEEDLE_mesh_lod"),de=Symbol("NEEDLE_texture_lod");let ie=null;function ze(){const o=pt();o&&(o.mapURLs(function(e){return ke(),e}),ke(),ie==null||ie.disconnect(),ie=new MutationObserver(e=>{e.forEach(t=>{t.addedNodes.forEach(s=>{s instanceof HTMLElement&&s.tagName.toLowerCase()==="model-viewer"&&Ve(s)})})}),ie.observe(document,{childList:!0,subtree:!0}))}function pt(){if(typeof customElements>"u")return null;const o=customElements.get("model-viewer");return o||(customElements.whenDefined("model-viewer").then(()=>{console.debug("[gltf-progressive] model-viewer defined"),ze()}),null)}function ke(){if(typeof document>"u")return;document.querySelectorAll("model-viewer").forEach(e=>{Ve(e)})}const Ie=new WeakSet;let yt=0;function Ve(o){if(!o||Ie.has(o))return null;Ie.add(o),console.debug("[gltf-progressive] found new model-viewer..."+ ++yt+`
`,o.getAttribute("src"));let e=null,t=null,s=null;for(let i=o;i!=null;i=Object.getPrototypeOf(i)){const n=Object.getOwnPropertySymbols(i),r=n.find(f=>f.toString()=="Symbol(renderer)"),a=n.find(f=>f.toString()=="Symbol(scene)"),l=n.find(f=>f.toString()=="Symbol(needsRender)");!e&&r!=null&&(e=o[r].threeRenderer),!t&&a!=null&&(t=o[a]),!s&&l!=null&&(s=o[l])}if(e&&t){let n=function(){if(s){let r=0,a=setInterval(()=>{if(r++>5){clearInterval(a);return}s==null||s.call(o)},300)}};console.debug("[gltf-progressive] setup model-viewer");const i=pe.get(e,{engine:"model-viewer"});return pe.addPlugin(new mt),i.enable(),i.addEventListener("changed",()=>{s==null||s.call(o)}),o.addEventListener("model-visibility",r=>{r.detail.visible&&(s==null||s.call(o))}),o.addEventListener("load",()=>{n()}),()=>{i.disable()}}return null}class mt{constructor(){d(this,"_didWarnAboutMissingUrl",!1)}onBeforeUpdateLOD(e,t,s,i){this.tryParseMeshLOD(t,i),this.tryParseTextureLOD(t,i)}getUrl(e){if(!e)return null;let t=e.getAttribute("src");return t||(t=e.src),t||(this._didWarnAboutMissingUrl||console.warn("No url found in modelviewer",e),this._didWarnAboutMissingUrl=!0),t}tryGetCurrentGLTF(e){return e._currentGLTF}tryGetCurrentModelViewer(e){return e.element}tryParseTextureLOD(e,t){if(t[de]==!0)return;t[de]=!0;const s=this.tryGetCurrentGLTF(e),i=this.tryGetCurrentModelViewer(e),n=this.getUrl(i);if(n&&s&&t.material){let a=function(l){var c,g,p;if(l[de]==!0)return;l[de]=!0,l.userData&&(l.userData.LOD=-1);const f=Object.keys(l);for(let M=0;M<f.length;M++){const O=f[M],x=l[O];if((x==null?void 0:x.isTexture)===!0){const U=(g=(c=x.userData)==null?void 0:c.associations)==null?void 0:g.textures;if(U==null)continue;const D=s.parser.json.textures[U];if(!D){console.warn("Texture data not found for texture index "+U);continue}if((p=D==null?void 0:D.extensions)!=null&&p[K]){const h=D.extensions[K];h&&n&&A.registerTexture(n,x,h.lods.length,U,h)}}}};const r=t.material;if(Array.isArray(r))for(const l of r)a(l);else a(r)}}tryParseMeshLOD(e,t){var r,a;if(t[Be]==!0)return;t[Be]=!0;const s=this.tryGetCurrentModelViewer(e),i=this.getUrl(s);if(!i)return;const n=(a=(r=t.userData)==null?void 0:r.gltfExtensions)==null?void 0:a[K];if(n&&i){const l=t.uuid;A.registerMesh(i,l,t,0,n.lods.length,n)}}}function Lt(o,e,t,s){Ue(e),Fe(t),Ne(t,{progressive:!0,...s==null?void 0:s.hints}),t.register(n=>new A(n,o));const i=pe.get(e);return(s==null?void 0:s.enableLODsManager)!==!1&&i.enable(),i}ze();if(!lt){const o={gltfProgressive:{useNeedleProgressive:Lt,LODsManager:pe,configureLoader:Ne,getRaycastMesh:le,useRaycastMeshes:ft}};if(!globalThis.Needle)globalThis.Needle=o;else for(const e in o)globalThis.Needle[e]=o[e]}export{pe as L,A as N,nt as a,Fe as b,Ue as c,Ne as d,le as g,rt as s};
