import{a2 as En,V as L,l as Y,bB as zn,bK as J,cR as Z,S as $n,b as ot,d as K,w as kn,q as Hn,r as Xn,F as hn}from"./three@0.169.5.js";const vn=0,jn=1,Zn=2,Ws=0,Js=1,wn=2,Kt=1.25,An=1,Ut=6*4+4+4,Zt=65535,Yn=Math.pow(2,-24),Wt=Symbol("SKIP_GENERATION");function Kn(e){return e.index?e.index.count:e.attributes.position.count}function mt(e){return Kn(e)/3}function Wn(e,n=ArrayBuffer){return e>65535?new Uint32Array(new n(4*e)):new Uint16Array(new n(2*e))}function Jn(e,n){if(!e.index){const t=e.attributes.position.count,s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r=Wn(t,s);e.setIndex(new En(r,1));for(let l=0;l<t;l++)r[l]=l}}function Vn(e,n){const t=mt(e),s=n||e.drawRange,r=s.start/3,l=(s.start+s.count)/3,i=Math.max(0,r),c=Math.min(t,l)-i;return[{offset:Math.floor(i),count:Math.floor(c)}]}function Rn(e,n){if(!e.groups||!e.groups.length)return Vn(e,n);const t=[],s=new Set,r=n||e.drawRange,l=r.start/3,i=(r.start+r.count)/3;for(const o of e.groups){const p=o.start/3,f=(o.start+o.count)/3;s.add(Math.max(l,p)),s.add(Math.min(i,f))}const c=Array.from(s.values()).sort((o,p)=>o-p);for(let o=0;o<c.length-1;o++){const p=c[o],f=c[o+1];t.push({offset:Math.floor(p),count:Math.floor(f-p)})}return t}function Qn(e,n){const t=mt(e),s=Rn(e,n).sort((i,c)=>i.offset-c.offset),r=s[s.length-1];r.count=Math.min(t-r.offset,r.count);let l=0;return s.forEach(({count:i})=>l+=i),t!==l}function Jt(e,n,t,s,r){let l=1/0,i=1/0,c=1/0,o=-1/0,p=-1/0,f=-1/0,u=1/0,a=1/0,y=1/0,A=-1/0,B=-1/0,x=-1/0;for(let m=n*6,d=(n+t)*6;m<d;m+=6){const h=e[m+0],T=e[m+1],w=h-T,P=h+T;w<l&&(l=w),P>o&&(o=P),h<u&&(u=h),h>A&&(A=h);const b=e[m+2],S=e[m+3],g=b-S,M=b+S;g<i&&(i=g),M>p&&(p=M),b<a&&(a=b),b>B&&(B=b);const C=e[m+4],_=e[m+5],U=C-_,F=C+_;U<c&&(c=U),F>f&&(f=F),C<y&&(y=C),C>x&&(x=C)}s[0]=l,s[1]=i,s[2]=c,s[3]=o,s[4]=p,s[5]=f,r[0]=u,r[1]=a,r[2]=y,r[3]=A,r[4]=B,r[5]=x}function On(e,n=null,t=null,s=null){const r=e.attributes.position,l=e.index?e.index.array:null,i=mt(e),c=r.normalized;let o;n===null?(o=new Float32Array(i*6),t=0,s=i):(o=n,t=t||0,s=s||i);const p=r.array,f=r.offset||0;let u=3;r.isInterleavedBufferAttribute&&(u=r.data.stride);const a=["getX","getY","getZ"];for(let y=t;y<t+s;y++){const A=y*3,B=y*6;let x=A+0,m=A+1,d=A+2;l&&(x=l[x],m=l[m],d=l[d]),c||(x=x*u+f,m=m*u+f,d=d*u+f);for(let h=0;h<3;h++){let T,w,P;c?(T=r[a[h]](x),w=r[a[h]](m),P=r[a[h]](d)):(T=p[x+h],w=p[m+h],P=p[d+h]);let b=T;w<b&&(b=w),P<b&&(b=P);let S=T;w>S&&(S=w),P>S&&(S=P);const g=(S-b)/2,M=h*2;o[B+M+0]=b+g,o[B+M+1]=g+(Math.abs(b)+g)*Yn}}return o}function v(e,n,t){return t.min.x=n[e],t.min.y=n[e+1],t.min.z=n[e+2],t.max.x=n[e+3],t.max.y=n[e+4],t.max.z=n[e+5],t}function Tn(e){let n=-1,t=-1/0;for(let s=0;s<3;s++){const r=e[s+3]-e[s];r>t&&(t=r,n=s)}return n}function Bn(e,n){n.set(e)}function bn(e,n,t){let s,r;for(let l=0;l<3;l++){const i=l+3;s=e[l],r=n[l],t[l]=s<r?s:r,s=e[i],r=n[i],t[i]=s>r?s:r}}function Ft(e,n,t){for(let s=0;s<3;s++){const r=n[e+2*s],l=n[e+2*s+1],i=r-l,c=r+l;i<t[s]&&(t[s]=i),c>t[s+3]&&(t[s+3]=c)}}function wt(e){const n=e[3]-e[0],t=e[4]-e[1],s=e[5]-e[2];return 2*(n*t+t*s+s*n)}const W=32,Gn=(e,n)=>e.candidate-n.candidate,G=new Array(W).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Et=new Float32Array(6);function ts(e,n,t,s,r,l){let i=-1,c=0;if(l===vn)i=Tn(n),i!==-1&&(c=(n[i]+n[i+3])/2);else if(l===jn)i=Tn(e),i!==-1&&(c=ns(t,s,r,i));else if(l===Zn){const o=wt(e);let p=Kt*r;const f=s*6,u=(s+r)*6;for(let a=0;a<3;a++){const y=n[a],x=(n[a+3]-y)/W;if(r<W/4){const m=[...G];m.length=r;let d=0;for(let T=f;T<u;T+=6,d++){const w=m[d];w.candidate=t[T+2*a],w.count=0;const{bounds:P,leftCacheBounds:b,rightCacheBounds:S}=w;for(let g=0;g<3;g++)S[g]=1/0,S[g+3]=-1/0,b[g]=1/0,b[g+3]=-1/0,P[g]=1/0,P[g+3]=-1/0;Ft(T,t,P)}m.sort(Gn);let h=r;for(let T=0;T<h;T++){const w=m[T];for(;T+1<h&&m[T+1].candidate===w.candidate;)m.splice(T+1,1),h--}for(let T=f;T<u;T+=6){const w=t[T+2*a];for(let P=0;P<h;P++){const b=m[P];w>=b.candidate?Ft(T,t,b.rightCacheBounds):(Ft(T,t,b.leftCacheBounds),b.count++)}}for(let T=0;T<h;T++){const w=m[T],P=w.count,b=r-w.count,S=w.leftCacheBounds,g=w.rightCacheBounds;let M=0;P!==0&&(M=wt(S)/o);let C=0;b!==0&&(C=wt(g)/o);const _=An+Kt*(M*P+C*b);_<p&&(i=a,p=_,c=w.candidate)}}else{for(let h=0;h<W;h++){const T=G[h];T.count=0,T.candidate=y+x+h*x;const w=T.bounds;for(let P=0;P<3;P++)w[P]=1/0,w[P+3]=-1/0}for(let h=f;h<u;h+=6){let P=~~((t[h+2*a]-y)/x);P>=W&&(P=W-1);const b=G[P];b.count++,Ft(h,t,b.bounds)}const m=G[W-1];Bn(m.bounds,m.rightCacheBounds);for(let h=W-2;h>=0;h--){const T=G[h],w=G[h+1];bn(T.bounds,w.rightCacheBounds,T.rightCacheBounds)}let d=0;for(let h=0;h<W-1;h++){const T=G[h],w=T.count,P=T.bounds,S=G[h+1].rightCacheBounds;w!==0&&(d===0?Bn(P,Et):bn(P,Et,Et)),d+=w;let g=0,M=0;d!==0&&(g=wt(Et)/o);const C=r-d;C!==0&&(M=wt(S)/o);const _=An+Kt*(g*d+M*C);_<p&&(i=a,p=_,c=T.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${l} used.`);return{axis:i,pos:c}}function ns(e,n,t,s){let r=0;for(let l=n,i=n+t;l<i;l++)r+=e[l*6+s*2];return r/t}class Qt{constructor(){this.boundingData=new Float32Array(6)}}function ss(e,n,t,s,r,l){let i=s,c=s+r-1;const o=l.pos,p=l.axis*2;for(;;){for(;i<=c&&t[i*6+p]<o;)i++;for(;i<=c&&t[c*6+p]>=o;)c--;if(i<c){for(let f=0;f<3;f++){let u=n[i*3+f];n[i*3+f]=n[c*3+f],n[c*3+f]=u}for(let f=0;f<6;f++){let u=t[i*6+f];t[i*6+f]=t[c*6+f],t[c*6+f]=u}i++,c--}else return i}}function es(e,n,t,s,r,l){let i=s,c=s+r-1;const o=l.pos,p=l.axis*2;for(;;){for(;i<=c&&t[i*6+p]<o;)i++;for(;i<=c&&t[c*6+p]>=o;)c--;if(i<c){let f=e[i];e[i]=e[c],e[c]=f;for(let u=0;u<6;u++){let a=t[i*6+u];t[i*6+u]=t[c*6+u],t[c*6+u]=a}i++,c--}else return i}}function N(e,n){return n[e+15]===65535}function I(e,n){return n[e+6]}function q(e,n){return n[e+14]}function $(e){return e+8}function k(e,n){return n[e+6]}function Dn(e,n){return n[e+7]}function Qs(e){return e}let Nn,Ct,Xt,In;const is=Math.pow(2,32);function on(e){return"count"in e?1:1+on(e.left)+on(e.right)}function rs(e,n,t){return Nn=new Float32Array(t),Ct=new Uint32Array(t),Xt=new Uint16Array(t),In=new Uint8Array(t),cn(e,n)}function cn(e,n){const t=e/4,s=e/2,r="count"in n,l=n.boundingData;for(let i=0;i<6;i++)Nn[t+i]=l[i];if(r)if(n.buffer){const i=n.buffer;In.set(new Uint8Array(i),e);for(let c=e,o=e+i.byteLength;c<o;c+=Ut){const p=c/2;N(p,Xt)||(Ct[c/4+6]+=t)}return e+i.byteLength}else{const i=n.offset,c=n.count;return Ct[t+6]=i,Xt[s+14]=c,Xt[s+15]=Zt,e+Ut}else{const i=n.left,c=n.right,o=n.splitAxis;let p;if(p=cn(e+Ut,i),p/4>is)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ct[t+6]=p/4,p=cn(p,c),Ct[t+7]=o,p}}function os(e,n){const t=(e.index?e.index.count:e.attributes.position.count)/3,s=t>2**16,r=s?4:2,l=n?new SharedArrayBuffer(t*r):new ArrayBuffer(t*r),i=s?new Uint32Array(l):new Uint16Array(l);for(let c=0,o=i.length;c<o;c++)i[c]=c;return i}function cs(e,n,t,s,r){const{maxDepth:l,verbose:i,maxLeafTris:c,strategy:o,onProgress:p,indirect:f}=r,u=e._indirectBuffer,a=e.geometry,y=a.index?a.index.array:null,A=f?es:ss,B=mt(a),x=new Float32Array(6);let m=!1;const d=new Qt;return Jt(n,t,s,d.boundingData,x),T(d,t,s,x),d;function h(w){p&&p(w/B)}function T(w,P,b,S=null,g=0){if(!m&&g>=l&&(m=!0,i&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),b<=c||g>=l)return h(P+b),w.offset=P,w.count=b,w;const M=ts(w.boundingData,S,n,P,b,o);if(M.axis===-1)return h(P+b),w.offset=P,w.count=b,w;const C=A(u,y,n,P,b,M);if(C===P||C===P+b)h(P+b),w.offset=P,w.count=b;else{w.splitAxis=M.axis;const _=new Qt,U=P,F=C-P;w.left=_,Jt(n,U,F,_.boundingData,x),T(_,U,F,x,g+1);const E=new Qt,V=C,O=b-F;w.right=E,Jt(n,V,O,E.boundingData,x),T(E,V,O,x,g+1)}return w}}function ls(e,n){const t=e.geometry;n.indirect&&(e._indirectBuffer=os(t,n.useSharedArrayBuffer),Qn(t,n.range)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||Jn(t,n);const s=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,r=On(t),l=n.indirect?Vn(t,n.range):Rn(t,n.range);e._roots=l.map(i=>{const c=cs(e,r,i.offset,i.count,n),o=on(c),p=new s(Ut*o);return rs(0,c,p),p})}class Q{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(n,t){let s=1/0,r=-1/0;for(let l=0,i=n.length;l<i;l++){const o=n[l][t];s=o<s?o:s,r=o>r?o:r}this.min=s,this.max=r}setFromPoints(n,t){let s=1/0,r=-1/0;for(let l=0,i=t.length;l<i;l++){const c=t[l],o=n.dot(c);s=o<s?o:s,r=o>r?o:r}this.min=s,this.max=r}isSeparated(n){return this.min>n.max||n.min>this.max}}Q.prototype.setFromBox=function(){const e=new L;return function(t,s){const r=s.min,l=s.max;let i=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){e.x=r.x*o+l.x*(1-o),e.y=r.y*p+l.y*(1-p),e.z=r.z*f+l.z*(1-f);const u=t.dot(e);i=Math.min(u,i),c=Math.max(u,c)}this.min=i,this.max=c}}();const as=function(){const e=new L,n=new L,t=new L;return function(r,l,i){const c=r.start,o=e,p=l.start,f=n;t.subVectors(c,p),e.subVectors(r.end,r.start),n.subVectors(l.end,l.start);const u=t.dot(f),a=f.dot(o),y=f.dot(f),A=t.dot(o),x=o.dot(o)*y-a*a;let m,d;x!==0?m=(u*a-A*y)/x:m=0,d=(u+m*a)/y,i.x=m,i.y=d}}(),mn=function(){const e=new Y,n=new L,t=new L;return function(r,l,i,c){as(r,l,e);let o=e.x,p=e.y;if(o>=0&&o<=1&&p>=0&&p<=1){r.at(o,i),l.at(p,c);return}else if(o>=0&&o<=1){p<0?l.at(0,c):l.at(1,c),r.closestPointToPoint(c,!0,i);return}else if(p>=0&&p<=1){o<0?r.at(0,i):r.at(1,i),l.closestPointToPoint(i,!0,c);return}else{let f;o<0?f=r.start:f=r.end;let u;p<0?u=l.start:u=l.end;const a=n,y=t;if(r.closestPointToPoint(u,!0,n),l.closestPointToPoint(f,!0,t),a.distanceToSquared(u)<=y.distanceToSquared(f)){i.copy(a),c.copy(u);return}else{i.copy(f),c.copy(y);return}}}}(),fs=function(){const e=new L,n=new L,t=new zn,s=new J;return function(l,i){const{radius:c,center:o}=l,{a:p,b:f,c:u}=i;if(s.start=p,s.end=f,s.closestPointToPoint(o,!0,e).distanceTo(o)<=c||(s.start=p,s.end=u,s.closestPointToPoint(o,!0,e).distanceTo(o)<=c)||(s.start=f,s.end=u,s.closestPointToPoint(o,!0,e).distanceTo(o)<=c))return!0;const B=i.getPlane(t);if(Math.abs(B.distanceToPoint(o))<=c){const m=B.projectPoint(o,n);if(i.containsPoint(m))return!0}return!1}}(),us=1e-15;function Ot(e){return Math.abs(e)<us}class j extends Z{constructor(...n){super(...n),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new Q),this.points=[this.a,this.b,this.c],this.sphere=new $n,this.plane=new zn,this.needsUpdate=!0}intersectsSphere(n){return fs(n,this)}update(){const n=this.a,t=this.b,s=this.c,r=this.points,l=this.satAxes,i=this.satBounds,c=l[0],o=i[0];this.getNormal(c),o.setFromPoints(c,r);const p=l[1],f=i[1];p.subVectors(n,t),f.setFromPoints(p,r);const u=l[2],a=i[2];u.subVectors(t,s),a.setFromPoints(u,r);const y=l[3],A=i[3];y.subVectors(s,n),A.setFromPoints(y,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,n),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const e=new L,n=new L,t=new J;return function(r,l=null,i=null){const{start:c,end:o}=r,p=this.points;let f,u=1/0;for(let a=0;a<3;a++){const y=(a+1)%3;t.start.copy(p[a]),t.end.copy(p[y]),mn(t,r,e,n),f=e.distanceToSquared(n),f<u&&(u=f,l&&l.copy(e),i&&i.copy(n))}return this.closestPointToPoint(c,e),f=c.distanceToSquared(e),f<u&&(u=f,l&&l.copy(e),i&&i.copy(c)),this.closestPointToPoint(o,e),f=o.distanceToSquared(e),f<u&&(u=f,l&&l.copy(e),i&&i.copy(o)),Math.sqrt(u)}}();j.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new Array(3),s=new Q,r=new Q,l=new L,i=new L,c=new L,o=new L,p=new L,f=new J,u=new J,a=new J,y=new L;function A(B,x,m){const d=B.points;let h=0,T=-1;for(let w=0;w<3;w++){const{start:P,end:b}=f;P.copy(d[w]),b.copy(d[(w+1)%3]),f.delta(i);const S=Ot(x.distanceToPoint(P));if(Ot(x.normal.dot(i))&&S){m.copy(f),h=2;break}const g=x.intersectLine(f,y);if(!g&&S&&y.copy(P),(g||S)&&!Ot(y.distanceTo(b))){if(h<=1)(h===1?m.start:m.end).copy(y),S&&(T=h);else if(h>=2){(T===1?m.start:m.end).copy(y),h=2;break}if(h++,h===2&&T===-1)break}}return h}return function(x,m=null,d=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(e.copy(x),e.update(),x=e);const h=this.plane,T=x.plane;if(Math.abs(h.normal.dot(T.normal))>1-1e-10){const w=this.satBounds,P=this.satAxes;t[0]=x.a,t[1]=x.b,t[2]=x.c;for(let g=0;g<4;g++){const M=w[g],C=P[g];if(s.setFromPoints(C,t),M.isSeparated(s))return!1}const b=x.satBounds,S=x.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let g=0;g<4;g++){const M=b[g],C=S[g];if(s.setFromPoints(C,n),M.isSeparated(s))return!1}for(let g=0;g<4;g++){const M=P[g];for(let C=0;C<4;C++){const _=S[C];if(l.crossVectors(M,_),s.setFromPoints(l,n),r.setFromPoints(l,t),s.isSeparated(r))return!1}}return m&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const w=A(this,T,u);if(w===1&&x.containsPoint(u.end))return m&&(m.start.copy(u.end),m.end.copy(u.end)),!0;if(w!==2)return!1;const P=A(x,h,a);if(P===1&&this.containsPoint(a.end))return m&&(m.start.copy(a.end),m.end.copy(a.end)),!0;if(P!==2)return!1;if(u.delta(c),a.delta(o),c.dot(o)<0){let U=a.start;a.start=a.end,a.end=U}const b=u.start.dot(c),S=u.end.dot(c),g=a.start.dot(c),M=a.end.dot(c),C=S<g,_=b<M;return b!==M&&g!==S&&C===_?!1:(m&&(p.subVectors(u.start,a.start),p.dot(c)>0?m.start.copy(u.start):m.start.copy(a.start),p.subVectors(u.end,a.end),p.dot(c)<0?m.end.copy(u.end):m.end.copy(a.end)),!0)}}}();j.prototype.distanceToPoint=function(){const e=new L;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();j.prototype.distanceToTriangle=function(){const e=new L,n=new L,t=["a","b","c"],s=new J,r=new J;return function(i,c=null,o=null){const p=c||o?s:null;if(this.intersectsTriangle(i,p))return(c||o)&&(c&&p.getCenter(c),o&&p.getCenter(o)),0;let f=1/0;for(let u=0;u<3;u++){let a;const y=t[u],A=i[y];this.closestPointToPoint(A,e),a=A.distanceToSquared(e),a<f&&(f=a,c&&c.copy(e),o&&o.copy(A));const B=this[y];i.closestPointToPoint(B,e),a=B.distanceToSquared(e),a<f&&(f=a,c&&c.copy(B),o&&o.copy(e))}for(let u=0;u<3;u++){const a=t[u],y=t[(u+1)%3];s.set(this[a],this[y]);for(let A=0;A<3;A++){const B=t[A],x=t[(A+1)%3];r.set(i[B],i[x]),mn(s,r,e,n);const m=e.distanceToSquared(n);m<f&&(f=m,c&&c.copy(e),o&&o.copy(n))}}return Math.sqrt(f)}}();class D{constructor(n,t,s){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new ot,this.invMatrix=new ot,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new Q),this.alignedSatBounds=new Array(3).fill().map(()=>new Q),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),s&&this.matrix.copy(s)}set(n,t,s){this.min.copy(n),this.max.copy(t),this.matrix.copy(s),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}D.prototype.update=function(){return function(){const n=this.matrix,t=this.min,s=this.max,r=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const a=1*p|2*f|4*u,y=r[a];y.x=p?s.x:t.x,y.y=f?s.y:t.y,y.z=u?s.z:t.z,y.applyMatrix4(n)}const l=this.satBounds,i=this.satAxes,c=r[0];for(let p=0;p<3;p++){const f=i[p],u=l[p],a=1<<p,y=r[a];f.subVectors(c,y),u.setFromPoints(f,r)}const o=this.alignedSatBounds;o[0].setFromPointsField(r,"x"),o[1].setFromPointsField(r,"y"),o[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();D.prototype.intersectsBox=function(){const e=new Q;return function(t){this.needsUpdate&&this.update();const s=t.min,r=t.max,l=this.satBounds,i=this.satAxes,c=this.alignedSatBounds;if(e.min=s.x,e.max=r.x,c[0].isSeparated(e)||(e.min=s.y,e.max=r.y,c[1].isSeparated(e))||(e.min=s.z,e.max=r.z,c[2].isSeparated(e)))return!1;for(let o=0;o<3;o++){const p=i[o],f=l[o];if(e.setFromBox(p,t),f.isSeparated(e))return!1}return!0}}();D.prototype.intersectsTriangle=function(){const e=new j,n=new Array(3),t=new Q,s=new Q,r=new L;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(e.copy(i),e.update(),i=e);const c=this.satBounds,o=this.satAxes;n[0]=i.a,n[1]=i.b,n[2]=i.c;for(let a=0;a<3;a++){const y=c[a],A=o[a];if(t.setFromPoints(A,n),y.isSeparated(t))return!1}const p=i.satBounds,f=i.satAxes,u=this.points;for(let a=0;a<3;a++){const y=p[a],A=f[a];if(t.setFromPoints(A,u),y.isSeparated(t))return!1}for(let a=0;a<3;a++){const y=o[a];for(let A=0;A<4;A++){const B=f[A];if(r.crossVectors(y,B),t.setFromPoints(r,n),s.setFromPoints(r,u),t.isSeparated(s))return!1}}return!0}}();D.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();D.prototype.distanceToPoint=function(){const e=new L;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}();D.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map(()=>new J),t=new Array(12).fill().map(()=>new J),s=new L,r=new L;return function(i,c=0,o=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(o||p)&&(i.getCenter(r),this.closestPointToPoint(r,s),i.closestPointToPoint(s,r),o&&o.copy(s),p&&p.copy(r)),0;const f=c*c,u=i.min,a=i.max,y=this.points;let A=1/0;for(let x=0;x<8;x++){const m=y[x];r.copy(m).clamp(u,a);const d=m.distanceToSquared(r);if(d<A&&(A=d,o&&o.copy(m),p&&p.copy(r),d<f))return Math.sqrt(d)}let B=0;for(let x=0;x<3;x++)for(let m=0;m<=1;m++)for(let d=0;d<=1;d++){const h=(x+1)%3,T=(x+2)%3,w=m<<h|d<<T,P=1<<x|m<<h|d<<T,b=y[w],S=y[P];n[B].set(b,S);const M=e[x],C=e[h],_=e[T],U=t[B],F=U.start,E=U.end;F[M]=u[M],F[C]=m?u[C]:a[C],F[_]=d?u[_]:a[C],E[M]=a[M],E[C]=m?u[C]:a[C],E[_]=d?u[_]:a[C],B++}for(let x=0;x<=1;x++)for(let m=0;m<=1;m++)for(let d=0;d<=1;d++){r.x=x?a.x:u.x,r.y=m?a.y:u.y,r.z=d?a.z:u.z,this.closestPointToPoint(r,s);const h=r.distanceToSquared(s);if(h<A&&(A=h,o&&o.copy(s),p&&p.copy(r),h<f))return Math.sqrt(h)}for(let x=0;x<12;x++){const m=n[x];for(let d=0;d<12;d++){const h=t[d];mn(m,h,s,r);const T=s.distanceToSquared(r);if(T<A&&(A=T,o&&o.copy(s),p&&p.copy(r),T<f))return Math.sqrt(T)}}return Math.sqrt(A)}}();class xn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class ps extends xn{constructor(){super(()=>new j)}}const H=new ps;class ys{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=s=>{t&&n.push(t),t=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const z=new ys;let nt,dt;const ct=[],zt=new xn(()=>new K);function ds(e,n,t,s,r,l){nt=zt.getPrimitive(),dt=zt.getPrimitive(),ct.push(nt,dt),z.setBuffer(e._roots[n]);const i=ln(0,e.geometry,t,s,r,l);z.clearBuffer(),zt.releasePrimitive(nt),zt.releasePrimitive(dt),ct.pop(),ct.pop();const c=ct.length;return c>0&&(dt=ct[c-1],nt=ct[c-2]),i}function ln(e,n,t,s,r=null,l=0,i=0){const{float32Array:c,uint16Array:o,uint32Array:p}=z;let f=e*2;if(N(f,o)){const a=I(e,p),y=q(f,o);return v(e,c,nt),s(a,y,!1,i,l+e,nt)}else{let M=function(_){const{uint16Array:U,uint32Array:F}=z;let E=_*2;for(;!N(E,U);)_=$(_),E=_*2;return I(_,F)},C=function(_){const{uint16Array:U,uint32Array:F}=z;let E=_*2;for(;!N(E,U);)_=k(_,F),E=_*2;return I(_,F)+q(E,U)};const a=$(e),y=k(e,p);let A=a,B=y,x,m,d,h;if(r&&(d=nt,h=dt,v(A,c,d),v(B,c,h),x=r(d),m=r(h),m<x)){A=y,B=a;const _=x;x=m,m=_,d=h}d||(d=nt,v(A,c,d));const T=N(A*2,o),w=t(d,T,x,i+1,l+A);let P;if(w===wn){const _=M(A),F=C(A)-_;P=s(_,F,!0,i+1,l+A,d)}else P=w&&ln(A,n,t,s,r,l,i+1);if(P)return!0;h=dt,v(B,c,h);const b=N(B*2,o),S=t(h,b,m,i+1,l+B);let g;if(S===wn){const _=M(B),F=C(B)-_;g=s(_,F,!0,i+1,l+B,h)}else g=S&&ln(B,n,t,s,r,l,i+1);return!!g}}const At=new L,Gt=new L;function ms(e,n,t={},s=0,r=1/0){const l=s*s,i=r*r;let c=1/0,o=null;if(e.shapecast({boundsTraverseOrder:f=>(At.copy(n).clamp(f.min,f.max),At.distanceToSquared(n)),intersectsBounds:(f,u,a)=>a<c&&a<i,intersectsTriangle:(f,u)=>{f.closestPointToPoint(n,At);const a=n.distanceToSquared(At);return a<c&&(Gt.copy(At),c=a,o=u),a<l}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(Gt):t.point=Gt.clone(),t.distance=p,t.faceIndex=o,t}const xs=parseInt(kn)>=169,et=new L,it=new L,rt=new L,vt=new Y,Vt=new Y,Rt=new Y,Pn=new L,gn=new L,Sn=new L,Tt=new L;function hs(e,n,t,s,r,l,i,c){let o;if(l===Hn?o=e.intersectTriangle(s,t,n,!0,r):o=e.intersectTriangle(n,t,s,l!==Xn,r),o===null)return null;const p=e.origin.distanceTo(r);return p<i||p>c?null:{distance:p,point:r.clone()}}function ws(e,n,t,s,r,l,i,c,o,p,f){et.fromBufferAttribute(n,l),it.fromBufferAttribute(n,i),rt.fromBufferAttribute(n,c);const u=hs(e,et,it,rt,Tt,o,p,f);if(u){const a=new L;Z.getBarycoord(Tt,et,it,rt,a),s&&(vt.fromBufferAttribute(s,l),Vt.fromBufferAttribute(s,i),Rt.fromBufferAttribute(s,c),u.uv=Z.getInterpolation(Tt,et,it,rt,vt,Vt,Rt,new Y)),r&&(vt.fromBufferAttribute(r,l),Vt.fromBufferAttribute(r,i),Rt.fromBufferAttribute(r,c),u.uv1=Z.getInterpolation(Tt,et,it,rt,vt,Vt,Rt,new Y)),t&&(Pn.fromBufferAttribute(t,l),gn.fromBufferAttribute(t,i),Sn.fromBufferAttribute(t,c),u.normal=Z.getInterpolation(Tt,et,it,rt,Pn,gn,Sn,new L),u.normal.dot(e.direction)>0&&u.normal.multiplyScalar(-1));const y={a:l,b:i,c,normal:new L,materialIndex:0};Z.getNormal(et,it,rt,y.normal),u.face=y,u.faceIndex=l,xs&&(u.barycoord=a)}return u}function Yt(e,n,t,s,r,l,i){const c=s*3;let o=c+0,p=c+1,f=c+2;const u=e.index;e.index&&(o=u.getX(o),p=u.getX(p),f=u.getX(f));const{position:a,normal:y,uv:A,uv1:B}=e.attributes,x=ws(t,a,y,A,B,o,p,f,n,l,i);return x?(x.faceIndex=s,r&&r.push(x),x):null}function R(e,n,t,s){const r=e.a,l=e.b,i=e.c;let c=n,o=n+1,p=n+2;t&&(c=t.getX(c),o=t.getX(o),p=t.getX(p)),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),l.x=s.getX(o),l.y=s.getY(o),l.z=s.getZ(o),i.x=s.getX(p),i.y=s.getY(p),i.z=s.getZ(p)}const Bt=new L,bt=new L,Pt=new L,_n=new Y,Mn=new Y,Cn=new Y;function Os(e,n,t,s){const r=n.getIndex().array,l=n.getAttribute("position"),i=n.getAttribute("uv"),c=r[t*3],o=r[t*3+1],p=r[t*3+2];Bt.fromBufferAttribute(l,c),bt.fromBufferAttribute(l,o),Pt.fromBufferAttribute(l,p);let f=0;const u=n.groups,a=t*3;for(let B=0,x=u.length;B<x;B++){const m=u[B],{start:d,count:h}=m;if(a>=d&&a<d+h){f=m.materialIndex;break}}const y=s&&s.barycoord?s.barycoord:new L;Z.getBarycoord(e,Bt,bt,Pt,y);let A=null;return i&&(_n.fromBufferAttribute(i,c),Mn.fromBufferAttribute(i,o),Cn.fromBufferAttribute(i,p),s&&s.uv?A=s.uv:A=new Y,Z.getInterpolation(e,Bt,bt,Pt,_n,Mn,Cn,A)),s?(s.face||(s.face={}),s.face.a=c,s.face.b=o,s.face.c=p,s.face.materialIndex=f,s.face.normal||(s.face.normal=new L),Z.getNormal(Bt,bt,Pt,s.face.normal),A&&(s.uv=A),s.barycoord=y,s):{face:{a:c,b:o,c:p,materialIndex:f,normal:Z.getNormal(Bt,bt,Pt,new L)},uv:A,barycoord:y}}function As(e,n,t,s,r,l,i,c){const{geometry:o,_indirectBuffer:p}=e;for(let f=s,u=s+r;f<u;f++)Yt(o,n,t,f,l,i,c)}function Ts(e,n,t,s,r,l,i){const{geometry:c,_indirectBuffer:o}=e;let p=1/0,f=null;for(let u=s,a=s+r;u<a;u++){let y;y=Yt(c,n,t,u,null,l,i),y&&y.distance<p&&(f=y,p=y.distance)}return f}function Bs(e,n,t,s,r,l,i){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let f=e,u=n+e;f<u;f++){let a;if(a=f,R(i,a*3,o,p),i.needsUpdate=!0,s(i,a,r,l))return!0}return!1}function bs(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,r=t.attributes.position;let l,i,c,o,p=0;const f=e._roots;for(let a=0,y=f.length;a<y;a++)l=f[a],i=new Uint32Array(l),c=new Uint16Array(l),o=new Float32Array(l),u(0,p),p+=l.byteLength;function u(a,y,A=!1){const B=a*2;if(c[B+15]===Zt){const m=i[a+6],d=c[B+14];let h=1/0,T=1/0,w=1/0,P=-1/0,b=-1/0,S=-1/0;for(let g=3*m,M=3*(m+d);g<M;g++){let C=s[g];const _=r.getX(C),U=r.getY(C),F=r.getZ(C);_<h&&(h=_),_>P&&(P=_),U<T&&(T=U),U>b&&(b=U),F<w&&(w=F),F>S&&(S=F)}return o[a+0]!==h||o[a+1]!==T||o[a+2]!==w||o[a+3]!==P||o[a+4]!==b||o[a+5]!==S?(o[a+0]=h,o[a+1]=T,o[a+2]=w,o[a+3]=P,o[a+4]=b,o[a+5]=S,!0):!1}else{const m=a+8,d=i[a+6],h=m+y,T=d+y;let w=A,P=!1,b=!1;n?w||(P=n.has(h),b=n.has(T),w=!P&&!b):(P=!0,b=!0);const S=w||P,g=w||b;let M=!1;S&&(M=u(m,y,w));let C=!1;g&&(C=u(d,y,w));const _=M||C;if(_)for(let U=0;U<3;U++){const F=m+U,E=d+U,V=o[F],O=o[F+3],xt=o[E],ht=o[E+3];o[a+U]=V<xt?V:xt,o[a+U+3]=O>ht?O:ht}return _}}}function st(e,n,t,s,r){let l,i,c,o,p,f;const u=1/t.direction.x,a=1/t.direction.y,y=1/t.direction.z,A=t.origin.x,B=t.origin.y,x=t.origin.z;let m=n[e],d=n[e+3],h=n[e+1],T=n[e+3+1],w=n[e+2],P=n[e+3+2];return u>=0?(l=(m-A)*u,i=(d-A)*u):(l=(d-A)*u,i=(m-A)*u),a>=0?(c=(h-B)*a,o=(T-B)*a):(c=(T-B)*a,o=(h-B)*a),l>o||c>i||((c>l||isNaN(l))&&(l=c),(o<i||isNaN(i))&&(i=o),y>=0?(p=(w-x)*y,f=(P-x)*y):(p=(P-x)*y,f=(w-x)*y),l>f||p>i)?!1:((p>l||l!==l)&&(l=p),(f<i||i!==i)&&(i=f),l<=r&&i>=s)}function Ps(e,n,t,s,r,l,i,c){const{geometry:o,_indirectBuffer:p}=e;for(let f=s,u=s+r;f<u;f++){let a=p?p[f]:f;Yt(o,n,t,a,l,i,c)}}function gs(e,n,t,s,r,l,i){const{geometry:c,_indirectBuffer:o}=e;let p=1/0,f=null;for(let u=s,a=s+r;u<a;u++){let y;y=Yt(c,n,t,o?o[u]:u,null,l,i),y&&y.distance<p&&(f=y,p=y.distance)}return f}function Ss(e,n,t,s,r,l,i){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let f=e,u=n+e;f<u;f++){let a;if(a=t.resolveTriangleIndex(f),R(i,a*3,o,p),i.needsUpdate=!0,s(i,a,r,l))return!0}return!1}function _s(e,n,t,s,r,l,i){z.setBuffer(e._roots[n]),an(0,e,t,s,r,l,i),z.clearBuffer()}function an(e,n,t,s,r,l,i){const{float32Array:c,uint16Array:o,uint32Array:p}=z,f=e*2;if(N(f,o)){const a=I(e,p),y=q(f,o);As(n,t,s,a,y,r,l,i)}else{const a=$(e);st(a,c,s,l,i)&&an(a,n,t,s,r,l,i);const y=k(e,p);st(y,c,s,l,i)&&an(y,n,t,s,r,l,i)}}const Ms=["x","y","z"];function Cs(e,n,t,s,r,l){z.setBuffer(e._roots[n]);const i=fn(0,e,t,s,r,l);return z.clearBuffer(),i}function fn(e,n,t,s,r,l){const{float32Array:i,uint16Array:c,uint32Array:o}=z;let p=e*2;if(N(p,c)){const u=I(e,o),a=q(p,c);return Ts(n,t,s,u,a,r,l)}else{const u=Dn(e,o),a=Ms[u],A=s.direction[a]>=0;let B,x;A?(B=$(e),x=k(e,o)):(B=k(e,o),x=$(e));const d=st(B,i,s,r,l)?fn(B,n,t,s,r,l):null;if(d){const w=d.point[a];if(A?w<=i[x+u]:w>=i[x+u+3])return d}const T=st(x,i,s,r,l)?fn(x,n,t,s,r,l):null;return d&&T?d.distance<=T.distance?d:T:d||T||null}}const Dt=new K,lt=new j,at=new j,gt=new ot,Un=new D,Nt=new D;function Us(e,n,t,s){z.setBuffer(e._roots[n]);const r=un(0,e,t,s);return z.clearBuffer(),r}function un(e,n,t,s,r=null){const{float32Array:l,uint16Array:i,uint32Array:c}=z;let o=e*2;if(r===null&&(t.boundingBox||t.computeBoundingBox(),Un.set(t.boundingBox.min,t.boundingBox.max,s),r=Un),N(o,i)){const f=n.geometry,u=f.index,a=f.attributes.position,y=t.index,A=t.attributes.position,B=I(e,c),x=q(o,i);if(gt.copy(s).invert(),t.boundsTree)return v(e,l,Nt),Nt.matrix.copy(gt),Nt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:d=>Nt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=B*3,T=(x+B)*3;h<T;h+=3)if(R(at,h,u,a),at.needsUpdate=!0,d.intersectsTriangle(at))return!0;return!1}});for(let m=B*3,d=(x+B)*3;m<d;m+=3){R(lt,m,u,a),lt.a.applyMatrix4(gt),lt.b.applyMatrix4(gt),lt.c.applyMatrix4(gt),lt.needsUpdate=!0;for(let h=0,T=y.count;h<T;h+=3)if(R(at,h,y,A),at.needsUpdate=!0,lt.intersectsTriangle(at))return!0}}else{const f=e+8,u=c[e+6];return v(f,l,Dt),!!(r.intersectsBox(Dt)&&un(f,n,t,s,r)||(v(u,l,Dt),r.intersectsBox(Dt)&&un(u,n,t,s,r)))}}const It=new ot,tn=new D,St=new D,Ls=new L,Fs=new L,Es=new L,zs=new L;function vs(e,n,t,s={},r={},l=0,i=1/0){n.boundingBox||n.computeBoundingBox(),tn.set(n.boundingBox.min,n.boundingBox.max,t),tn.needsUpdate=!0;const c=e.geometry,o=c.attributes.position,p=c.index,f=n.attributes.position,u=n.index,a=H.getPrimitive(),y=H.getPrimitive();let A=Ls,B=Fs,x=null,m=null;r&&(x=Es,m=zs);let d=1/0,h=null,T=null;return It.copy(t).invert(),St.matrix.copy(It),e.shapecast({boundsTraverseOrder:w=>tn.distanceToBox(w),intersectsBounds:(w,P,b)=>b<d&&b<i?(P&&(St.min.copy(w.min),St.max.copy(w.max),St.needsUpdate=!0),!0):!1,intersectsRange:(w,P)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:S=>St.distanceToBox(S),intersectsBounds:(S,g,M)=>M<d&&M<i,intersectsRange:(S,g)=>{for(let M=S,C=S+g;M<C;M++){R(y,3*M,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let _=w,U=w+P;_<U;_++){R(a,3*_,p,o),a.needsUpdate=!0;const F=a.distanceToTriangle(y,A,x);if(F<d&&(B.copy(A),m&&m.copy(x),d=F,h=_,T=M),F<l)return!0}}}});{const b=mt(n);for(let S=0,g=b;S<g;S++){R(y,3*S,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=w,C=w+P;M<C;M++){R(a,3*M,p,o),a.needsUpdate=!0;const _=a.distanceToTriangle(y,A,x);if(_<d&&(B.copy(A),m&&m.copy(x),d=_,h=M,T=S),_<l)return!0}}}}}),H.releasePrimitive(a),H.releasePrimitive(y),d===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=d,s.faceIndex=h,r&&(r.point?r.point.copy(m):r.point=m.clone(),r.point.applyMatrix4(It),B.applyMatrix4(It),r.distance=B.sub(r.point).length(),r.faceIndex=T),s)}function Vs(e,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=e.geometry,s=t.index?t.index.array:null,r=t.attributes.position;let l,i,c,o,p=0;const f=e._roots;for(let a=0,y=f.length;a<y;a++)l=f[a],i=new Uint32Array(l),c=new Uint16Array(l),o=new Float32Array(l),u(0,p),p+=l.byteLength;function u(a,y,A=!1){const B=a*2;if(c[B+15]===Zt){const m=i[a+6],d=c[B+14];let h=1/0,T=1/0,w=1/0,P=-1/0,b=-1/0,S=-1/0;for(let g=m,M=m+d;g<M;g++){const C=3*e.resolveTriangleIndex(g);for(let _=0;_<3;_++){let U=C+_;U=s?s[U]:U;const F=r.getX(U),E=r.getY(U),V=r.getZ(U);F<h&&(h=F),F>P&&(P=F),E<T&&(T=E),E>b&&(b=E),V<w&&(w=V),V>S&&(S=V)}}return o[a+0]!==h||o[a+1]!==T||o[a+2]!==w||o[a+3]!==P||o[a+4]!==b||o[a+5]!==S?(o[a+0]=h,o[a+1]=T,o[a+2]=w,o[a+3]=P,o[a+4]=b,o[a+5]=S,!0):!1}else{const m=a+8,d=i[a+6],h=m+y,T=d+y;let w=A,P=!1,b=!1;n?w||(P=n.has(h),b=n.has(T),w=!P&&!b):(P=!0,b=!0);const S=w||P,g=w||b;let M=!1;S&&(M=u(m,y,w));let C=!1;g&&(C=u(d,y,w));const _=M||C;if(_)for(let U=0;U<3;U++){const F=m+U,E=d+U,V=o[F],O=o[F+3],xt=o[E],ht=o[E+3];o[a+U]=V<xt?V:xt,o[a+U+3]=O>ht?O:ht}return _}}}function Rs(e,n,t,s,r,l,i){z.setBuffer(e._roots[n]),pn(0,e,t,s,r,l,i),z.clearBuffer()}function pn(e,n,t,s,r,l,i){const{float32Array:c,uint16Array:o,uint32Array:p}=z,f=e*2;if(N(f,o)){const a=I(e,p),y=q(f,o);Ps(n,t,s,a,y,r,l,i)}else{const a=$(e);st(a,c,s,l,i)&&pn(a,n,t,s,r,l,i);const y=k(e,p);st(y,c,s,l,i)&&pn(y,n,t,s,r,l,i)}}const Ds=["x","y","z"];function Ns(e,n,t,s,r,l){z.setBuffer(e._roots[n]);const i=yn(0,e,t,s,r,l);return z.clearBuffer(),i}function yn(e,n,t,s,r,l){const{float32Array:i,uint16Array:c,uint32Array:o}=z;let p=e*2;if(N(p,c)){const u=I(e,o),a=q(p,c);return gs(n,t,s,u,a,r,l)}else{const u=Dn(e,o),a=Ds[u],A=s.direction[a]>=0;let B,x;A?(B=$(e),x=k(e,o)):(B=k(e,o),x=$(e));const d=st(B,i,s,r,l)?yn(B,n,t,s,r,l):null;if(d){const w=d.point[a];if(A?w<=i[x+u]:w>=i[x+u+3])return d}const T=st(x,i,s,r,l)?yn(x,n,t,s,r,l):null;return d&&T?d.distance<=T.distance?d:T:d||T||null}}const qt=new K,ft=new j,ut=new j,_t=new ot,Ln=new D,$t=new D;function Is(e,n,t,s){z.setBuffer(e._roots[n]);const r=dn(0,e,t,s);return z.clearBuffer(),r}function dn(e,n,t,s,r=null){const{float32Array:l,uint16Array:i,uint32Array:c}=z;let o=e*2;if(r===null&&(t.boundingBox||t.computeBoundingBox(),Ln.set(t.boundingBox.min,t.boundingBox.max,s),r=Ln),N(o,i)){const f=n.geometry,u=f.index,a=f.attributes.position,y=t.index,A=t.attributes.position,B=I(e,c),x=q(o,i);if(_t.copy(s).invert(),t.boundsTree)return v(e,l,$t),$t.matrix.copy(_t),$t.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:d=>$t.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(s),d.b.applyMatrix4(s),d.c.applyMatrix4(s),d.needsUpdate=!0;for(let h=B,T=x+B;h<T;h++)if(R(ut,3*n.resolveTriangleIndex(h),u,a),ut.needsUpdate=!0,d.intersectsTriangle(ut))return!0;return!1}});for(let m=B,d=x+B;m<d;m++){const h=n.resolveTriangleIndex(m);R(ft,3*h,u,a),ft.a.applyMatrix4(_t),ft.b.applyMatrix4(_t),ft.c.applyMatrix4(_t),ft.needsUpdate=!0;for(let T=0,w=y.count;T<w;T+=3)if(R(ut,T,y,A),ut.needsUpdate=!0,ft.intersectsTriangle(ut))return!0}}else{const f=e+8,u=c[e+6];return v(f,l,qt),!!(r.intersectsBox(qt)&&dn(f,n,t,s,r)||(v(u,l,qt),r.intersectsBox(qt)&&dn(u,n,t,s,r)))}}const kt=new ot,nn=new D,Mt=new D,qs=new L,$s=new L,ks=new L,Hs=new L;function Xs(e,n,t,s={},r={},l=0,i=1/0){n.boundingBox||n.computeBoundingBox(),nn.set(n.boundingBox.min,n.boundingBox.max,t),nn.needsUpdate=!0;const c=e.geometry,o=c.attributes.position,p=c.index,f=n.attributes.position,u=n.index,a=H.getPrimitive(),y=H.getPrimitive();let A=qs,B=$s,x=null,m=null;r&&(x=ks,m=Hs);let d=1/0,h=null,T=null;return kt.copy(t).invert(),Mt.matrix.copy(kt),e.shapecast({boundsTraverseOrder:w=>nn.distanceToBox(w),intersectsBounds:(w,P,b)=>b<d&&b<i?(P&&(Mt.min.copy(w.min),Mt.max.copy(w.max),Mt.needsUpdate=!0),!0):!1,intersectsRange:(w,P)=>{if(n.boundsTree){const b=n.boundsTree;return b.shapecast({boundsTraverseOrder:S=>Mt.distanceToBox(S),intersectsBounds:(S,g,M)=>M<d&&M<i,intersectsRange:(S,g)=>{for(let M=S,C=S+g;M<C;M++){const _=b.resolveTriangleIndex(M);R(y,3*_,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let U=w,F=w+P;U<F;U++){const E=e.resolveTriangleIndex(U);R(a,3*E,p,o),a.needsUpdate=!0;const V=a.distanceToTriangle(y,A,x);if(V<d&&(B.copy(A),m&&m.copy(x),d=V,h=U,T=M),V<l)return!0}}}})}else{const b=mt(n);for(let S=0,g=b;S<g;S++){R(y,3*S,u,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=w,C=w+P;M<C;M++){const _=e.resolveTriangleIndex(M);R(a,3*_,p,o),a.needsUpdate=!0;const U=a.distanceToTriangle(y,A,x);if(U<d&&(B.copy(A),m&&m.copy(x),d=U,h=M,T=S),U<l)return!0}}}}}),H.releasePrimitive(a),H.releasePrimitive(y),d===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=d,s.faceIndex=h,r&&(r.point?r.point.copy(m):r.point=m.clone(),r.point.applyMatrix4(kt),B.applyMatrix4(kt),r.distance=B.sub(r.point).length(),r.faceIndex=T),s)}function js(){return typeof SharedArrayBuffer<"u"}const Lt=new z.constructor,jt=new z.constructor,tt=new xn(()=>new K),pt=new K,yt=new K,sn=new K,en=new K;let rn=!1;function Zs(e,n,t,s){if(rn)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");rn=!0;const r=e._roots,l=n._roots;let i,c=0,o=0;const p=new ot().copy(t).invert();for(let f=0,u=r.length;f<u;f++){Lt.setBuffer(r[f]),o=0;const a=tt.getPrimitive();v(0,Lt.float32Array,a),a.applyMatrix4(p);for(let y=0,A=l.length;y<A&&(jt.setBuffer(l[y]),i=X(0,0,t,p,s,c,o,0,0,a),jt.clearBuffer(),o+=l[y].length,!i);y++);if(tt.releasePrimitive(a),Lt.clearBuffer(),c+=r[f].length,i)break}return rn=!1,i}function X(e,n,t,s,r,l=0,i=0,c=0,o=0,p=null,f=!1){let u,a;f?(u=jt,a=Lt):(u=Lt,a=jt);const y=u.float32Array,A=u.uint32Array,B=u.uint16Array,x=a.float32Array,m=a.uint32Array,d=a.uint16Array,h=e*2,T=n*2,w=N(h,B),P=N(T,d);let b=!1;if(P&&w)f?b=r(I(n,m),q(n*2,d),I(e,A),q(e*2,B),o,i+n,c,l+e):b=r(I(e,A),q(e*2,B),I(n,m),q(n*2,d),c,l+e,o,i+n);else if(P){const S=tt.getPrimitive();v(n,x,S),S.applyMatrix4(t);const g=$(e),M=k(e,A);v(g,y,pt),v(M,y,yt);const C=S.intersectsBox(pt),_=S.intersectsBox(yt);b=C&&X(n,g,s,t,r,i,l,o,c+1,S,!f)||_&&X(n,M,s,t,r,i,l,o,c+1,S,!f),tt.releasePrimitive(S)}else{const S=$(n),g=k(n,m);v(S,x,sn),v(g,x,en);const M=p.intersectsBox(sn),C=p.intersectsBox(en);if(M&&C)b=X(e,S,t,s,r,l,i,c,o+1,p,f)||X(e,g,t,s,r,l,i,c,o+1,p,f);else if(M)if(w)b=X(e,S,t,s,r,l,i,c,o+1,p,f);else{const _=tt.getPrimitive();_.copy(sn).applyMatrix4(t);const U=$(e),F=k(e,A);v(U,y,pt),v(F,y,yt);const E=_.intersectsBox(pt),V=_.intersectsBox(yt);b=E&&X(S,U,s,t,r,i,l,o,c+1,_,!f)||V&&X(S,F,s,t,r,i,l,o,c+1,_,!f),tt.releasePrimitive(_)}else if(C)if(w)b=X(e,g,t,s,r,l,i,c,o+1,p,f);else{const _=tt.getPrimitive();_.copy(en).applyMatrix4(t);const U=$(e),F=k(e,A);v(U,y,pt),v(F,y,yt);const E=_.intersectsBox(pt),V=_.intersectsBox(yt);b=E&&X(g,U,s,t,r,i,l,o,c+1,_,!f)||V&&X(g,F,s,t,r,i,l,o,c+1,_,!f),tt.releasePrimitive(_)}}return b}const Ht=new D,Fn=new K,Ys={strategy:vn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class qn{static serialize(n,t={}){t={cloneBuffers:!0,...t};const s=n.geometry,r=n._roots,l=n._indirectBuffer,i=s.getIndex();let c;return t.cloneBuffers?c={roots:r.map(o=>o.slice()),index:i?i.array.slice():null,indirectBuffer:l?l.slice():null}:c={roots:r,index:i?i.array:null,indirectBuffer:l},c}static deserialize(n,t,s={}){s={setIndex:!0,indirect:!!n.indirectBuffer,...s};const{index:r,roots:l,indirectBuffer:i}=n,c=new qn(t,{...s,[Wt]:!0});if(c._roots=l,c._indirectBuffer=i||null,s.setIndex){const o=t.getIndex();if(o===null){const p=new En(n.index,1,!1);t.setIndex(p)}else o.array!==r&&(o.array.set(r),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Ys,[Wt]:!1},t),t.useSharedArrayBuffer&&!js())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[Wt]||(ls(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new K))),this.resolveTriangleIndex=t.indirect?s=>this._indirectBuffer[s]:s=>s}refit(n=null){return(this.indirect?Vs:bs)(this,n)}traverse(n,t=0){const s=this._roots[t],r=new Uint32Array(s),l=new Uint16Array(s);i(0);function i(c,o=0){const p=c*2,f=l[p+15]===Zt;if(f){const u=r[c+6],a=l[p+14];n(o,f,new Float32Array(s,c*4,6),u,a)}else{const u=c+Ut/4,a=r[c+6],y=r[c+7];n(o,f,new Float32Array(s,c*4,6),y)||(i(u,o+1),i(a,o+1))}}}raycast(n,t=hn,s=0,r=1/0){const l=this._roots,i=this.geometry,c=[],o=t.isMaterial,p=Array.isArray(t),f=i.groups,u=o?t.side:t,a=this.indirect?Rs:_s;for(let y=0,A=l.length;y<A;y++){const B=p?t[f[y].materialIndex].side:u,x=c.length;if(a(this,y,B,n,c,s,r),p){const m=f[y].materialIndex;for(let d=x,h=c.length;d<h;d++)c[d].face.materialIndex=m}}return c}raycastFirst(n,t=hn,s=0,r=1/0){const l=this._roots,i=this.geometry,c=t.isMaterial,o=Array.isArray(t);let p=null;const f=i.groups,u=c?t.side:t,a=this.indirect?Ns:Cs;for(let y=0,A=l.length;y<A;y++){const B=o?t[f[y].materialIndex].side:u,x=a(this,y,B,n,s,r);x!=null&&(p==null||x.distance<p.distance)&&(p=x,o&&(x.face.materialIndex=f[y].materialIndex))}return p}intersectsGeometry(n,t){let s=!1;const r=this._roots,l=this.indirect?Is:Us;for(let i=0,c=r.length;i<c&&(s=l(this,i,n,t),!s);i++);return s}shapecast(n){const t=H.getPrimitive(),s=this.indirect?Ss:Bs;let{boundsTraverseOrder:r,intersectsBounds:l,intersectsRange:i,intersectsTriangle:c}=n;if(i&&c){const u=i;i=(a,y,A,B,x)=>u(a,y,A,B,x)?!0:s(a,y,this,c,A,B,t)}else i||(c?i=(u,a,y,A)=>s(u,a,this,c,y,A,t):i=(u,a,y)=>y);let o=!1,p=0;const f=this._roots;for(let u=0,a=f.length;u<a;u++){const y=f[u];if(o=ds(this,u,l,i,r,p),o)break;p+=y.byteLength}return H.releasePrimitive(t),o}bvhcast(n,t,s){let{intersectsRanges:r,intersectsTriangles:l}=s;const i=H.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,p=this.indirect?A=>{const B=this.resolveTriangleIndex(A);R(i,B*3,c,o)}:A=>{R(i,A*3,c,o)},f=H.getPrimitive(),u=n.geometry.index,a=n.geometry.attributes.position,y=n.indirect?A=>{const B=n.resolveTriangleIndex(A);R(f,B*3,u,a)}:A=>{R(f,A*3,u,a)};if(l){const A=(B,x,m,d,h,T,w,P)=>{for(let b=m,S=m+d;b<S;b++){y(b),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let g=B,M=B+x;g<M;g++)if(p(g),i.needsUpdate=!0,l(i,f,g,b,h,T,w,P))return!0}return!1};if(r){const B=r;r=function(x,m,d,h,T,w,P,b){return B(x,m,d,h,T,w,P,b)?!0:A(x,m,d,h,T,w,P,b)}}else r=A}return Zs(this,n,t,r)}intersectsBox(n,t){return Ht.set(n.min,n.max,t),Ht.needsUpdate=!0,this.shapecast({intersectsBounds:s=>Ht.intersectsBox(s),intersectsTriangle:s=>Ht.intersectsTriangle(s)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,s={},r={},l=0,i=1/0){return(this.indirect?Xs:vs)(this,n,t,s,r,l,i)}closestPointToPoint(n,t={},s=0,r=1/0){return ms(this,n,t,s,r)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(s=>{v(0,new Float32Array(s),Fn),n.union(Fn)}),n}}export{jn as A,Ut as B,q as C,j as E,N as I,qn as M,Ws as N,I as O,k as R,Dn as S,Kt as T,v as a,An as b,Kn as c,Qs as d,vn as e,Zn as f,Wn as g,Js as h,js as i,wn as j,Os as k,D as l};
